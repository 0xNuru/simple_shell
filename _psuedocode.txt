size_t bytes_read, input_len;
char *input;
pid_t pid;
extern char **environ;
int status;

char *args[] = {input, NULL};

while (1) {
    display prompt "($) ";
    // read input from user
    bytes_read = getline(&input, &input_len, stdin);

    // error handling
    if (bytes_read == -1) {
        if (feof(stdin)) {
            // eof reached (ctrl + d)
            printf("\n");
        } else {
            perror("getline");
            printf("%s", input); // print the input that caused an error
            exit(EXIT_FAILURE);
        }
    }

    // CREATE CHILD PROCESS
    pid = fork();

    // error handling
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // child process
        execve(input, args, environ);

        // if control returns here, there is an error
        perror("execve");
        exit(EXIT_FAILURE);
    } else {
        waitpid(pid, &status, 0);
        if (WIFEXITED(status)) {
            printf("exit success\n");
        } else {
            printf("exited abnormally\n");
        }
        free(input);
        return 0;
    }
}
2-pseudo
